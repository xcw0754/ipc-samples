# pipe (无名管道)

pipe，即**无名管道**，简称管道，是IPC的一种，平常用的指令比如`cat tmp.txt | grep "abc"`这样就用到了无名管道。pipe一般用于有亲缘进程之间的通信，通常情况下它是半双工的容器(有些系统也提供全双工的pipe或者socketpair，这里不讨论)。"半双工"是指同一时刻的数据流只能是单向的，否则可能会达不到预期的效果。数据被读走后会自动删除管道内的数据，而双向通信则需要靠其他机制方式保证通信的正确性，不如考虑用两条管道更方便。

管道是一种特殊文件，由内核实现，它不依赖于任何文件系统，且只存在于内存。其大小一般为一页，即4096B，`$ulimit -a`可以看到这个值，这个值定义在头文件`limits.h`中的宏`PIPE_BUF`，一般不用去改它，改起来也麻烦，要重新编译内核。而管道的容量，`$man 7 pipe`提到了从Linux2.6.11之后，大小就为65536B，其他平台不清楚。


适用场景:
- 父子进程间的通信
- 兄弟进程间的通信
- 具有同一个祖先的进程间的通信

注:因为pipe是无名的管道，所以只有亲缘进程之间才能够找到指定的pipe，其实靠的就是`fork`之后父子进程共享句柄。(不考虑传递描述符的情况)



常见使用方法
-----

父子进程间的单向通信:

1. 父进程用`int pipe(int pipefd[2])`函数创建一个管道
2. 父进程调用fork创建一个子进程
3. 父进程关闭`pipefd[0]`，即管道的读端
4. 子进程关闭`pipefd[1]`，即管道的写端

现在，父进程拥有此管道的写端，子进程拥有此管道的读端，那么就可以实现父进程向子进程的单向数据流了，父进程调用`write`函数往管道写数据，子进程即可调用`read`函数从管道读出数据。


子进程间的单向通信:

1. 父进程用`int pipe(int pipefd[2])`函数创建一个管道
2. 父进程调用fork创建两个子进程
3. 父进程关闭`pipefd[0]`和`pipefd[1]`
4. 子进程1关闭`pipefd[0]`，即管道的读端
5. 子进程2关闭`pipefd[1]`，即管道的写端

现在，父进程无法操作此管道，子进程1拥有此管道的写端，子进程2拥有此管道的读端，那么就可以实现子进程1向子进程2的单向数据流了。其他的使用方法类似就可以写出来了。


父子进程间的双向通信:

1. 父进程用`int pipe(int pipefd[2])`函数创建两个管道
2. 父进程调用fork创建一个子进程
3. 父进程关闭A的读端，关闭B的写端
4. 子进程关闭A的写端，关闭B的读端

现在，A管道用于父进程向子进程的单向通信，B管道用于子进程向父进程的单向通信。



以上的方法都有提到关闭管道的读/写端，事实上可以不用关闭，只是为了防止误操作，关闭了会更好一点。况且，一般我们不会把管道当成是全双工来用，不是因为原子性问题，而是受限于pipe的设计，几乎不会涉及这种应用场景。


样例
-----

父子进程间的单向通信。下面的例子比较粗糙，长期运行的进程还应该注意更多细节。
```
#define BUFFER  "show me something"
int main()
{
    int pipefd[2];
    pid_t childpid;

    // 创建1条管道
    if (pipe(pipefd) != 0) {
        perror(strerror(errno));
        return -1;
    }

    // 子进程
    if ((childpid = fork()) == 0) {
        sleep(3);
        // 关闭写端
        close(pipefd[1]);
        char buf[64] = {0};
        read(pipefd[0], buf, strlen(BUFFER));
        printf("%s\n", buf);
        return 0;
    }

    // 父进程，关闭读端
    close(pipefd[0]);
    char buf[64] = BUFFER;
    write(pipefd[1], buf, strlen(buf));
    wait(NULL);
    return 0;
}

```




额外属性
-----

关于**阻塞与非阻塞**。pipe默认是阻塞的，虽然`write`不会阻塞，但是如果写满了管道再继续写的话就会阻塞了。使用`read`读一个管道时是会阻塞到数据到来才返回的，我们可以使用`fcntl`函数将管道设置成非阻塞，比如粗糙一点可以这样写:
```
int flags = fcntl(fd, F_GETFL, 0);
fcntl(fd, F_SETFL, flags | O_NONBLOCK);
// 正确写法应检查返回值！
```
但是别直接就写成`fcntl(fd, F_SETFL, O_NONBLOCK);`，这样会清除掉其他的flag。虽然是一条管道，但它是两个句柄，所以需要对两个句柄都设置一次非阻塞。将管道设置成非阻塞之后，每次`read`就不会阻塞了。每次`write`也不会阻塞，在管道写满时就会将errno置为`EAGAIN`。


关于**读写管道的原子性**。Linux内核已经保证了读写管道的原子性，但是有个前提，每次写管道的数据大小不能超过`PIPE_BUF`，否则内核不能保证该写操作的原子性。由于具有原子性，所以"多进程写,多进程读"这样的模型也是可以的。应该先启动读进程，再启动写进程，这样能够一定程度上减少写满管道的可能性。


关于**消息长度设计**。管道是以字节流传递数据的，流数据通常可以设计成不定长消息。可以在前n个字节指定后面数据的长度，这样就必须分两次`read`，先读n个字节得到数据长度，再读出具体长度的消息。也可以用特殊字符来分隔每个消息，但是这样就需要对数据中的特殊字符进行转义处理。


关于**管道的生存周期**。如果没有显示关闭的话，管道从`pipe`函数创建，到所有进程终止后销毁。某个进程终止，或关闭管道，都不会影响其他进程的管道的存在。


关于**效率**，数据从一个进程传递到另一个进程，需要经过两次拷贝，用户区->内核区，以及内核区->用户区，即进程1送数据进内核，内核送数据到进程2。`read`、`write`、`close`、`pipe`都是很耗时的系统调用，进程从用户态和内核态的转变需要切换上下文。



若干细节
-----

- 如果管道**当前数据量小于`read`第3个参数**，那么就只返回当前数据，这在返回值中体现，无论是阻塞或非阻塞式。

- 如果管道**当前空闲容量少于待写入的数据量**，那么阻塞式管道就会阻塞，非阻塞式管道就会得到`EAGAIN`。

- 如果**读进程异常退出**，写进程还往管道写数据，就会得到`SIGPIPE`信号，默认操作是终止进程。

- 如果**写进程异常退出**，读进程还在读数据，那么阻塞式管道就会返回0且置errno为0，非阻塞式管道就会返回-1且置errno为`EAGAIN`。

- 管道是以**字节流传递数据**的，如果传递的是结构体，在读出之后直接强制类型转换就行了，同台机器不必考虑网络字节序。(可考虑使用消息队列代替管道)



